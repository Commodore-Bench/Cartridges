;
; File generated by cc65 v 2.18 - Git 947dd9a
;
	.fopt		compiler,"cc65 v 2.18 - Git 947dd9a"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_sprintf
	.import		_strcmp
	.import		_memset
	.import		_malloc
	.import		_free
	.import		_clrscr
	.import		_kbhit
	.import		_gotoxy
	.import		_cputs
	.import		_cprintf
	.import		_cgetc
	.import		_revers
	.import		_textcolor
	.import		_joy_static_stddrv
	.import		_joy_install
	.import		_joy_read
	.import		_drawFrame
	.import		_initScreen
	.import		_readDir
	.import		_readDirPage
	.import		_waitKey
	.import		_ef3usb_check_cmd
	.import		_ef3usb_receive_data
	.import		_ef3usb_send_str
	.import		_kff_send_command
	.import		_kff_send_ext_command
	.import		_disk_mount_and_load
	.import		_usbtool_prg_load_and_run
	.import		_ef3usb_get_cmd
	.import		_wait_for_reset
	.import		_is_c128
	.export		_programNameVer
	.export		_padding
	.export		_main

.segment	"DATA"

_isC128:
	.byte	$00
_bigBuffer:
	.word	$0000
_dir:
	.word	$0000

.segment	"RODATA"

_textc:
	.byte	$0D
_backc:
	.byte	$04
_warnc:
	.byte	$07
_errorc:
	.byte	$0A
.segment	"LOWCODE"
_programNameVer:
	.byte	$CB,$55,$4E,$47,$20,$C6,$55,$20,$C6,$4C,$41,$53,$48,$20,$56,$31
	.byte	$2E,$58,$58,$00
_padding:
	.res	80,$00
.segment	"RODATA"
_programBar:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$CB,$55,$4E,$47,$20,$C6
	.byte	$55,$20,$C6,$4C,$41,$53,$48,$20,$56,$31,$2E,$58,$58,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$00
_menuBar:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$CB,$55,$4E,$47,$20,$C6
	.byte	$55,$20,$C6,$4C,$41,$53,$48,$20,$56,$31,$2E,$58,$58,$20,$20,$3C
	.byte	$C6,$31,$3E,$20,$C8,$45,$4C,$50,$00
S002A:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$00
S0022:
	.byte	$3C,$C6,$37,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$C2,$C1,$D3,$C9,$C3,$20,$28,$C3,$41,$52,$54,$20
	.byte	$C1,$43,$54,$49,$56,$45,$29,$00
S0029	:=	S002A+2
S0017	:=	S002A+2
S001A:
	.byte	$3C,$C3,$D2,$D3,$D2,$3E,$20,$4F,$52,$20,$CA,$4F,$59,$20,$20,$20
	.byte	$20,$20,$20,$20,$C3,$48,$41,$4E,$47,$45,$20,$53,$45,$4C,$45,$43
	.byte	$54,$49,$4F,$4E,$00
S0008:
	.byte	$C3,$4F,$4D,$4D,$55,$4E,$49,$43,$41,$54,$49,$4F,$4E,$20,$57,$49
	.byte	$54,$48,$20,$43,$41,$52,$54,$52,$49,$44,$47,$45,$20,$46,$41,$49
	.byte	$4C,$45,$44,$2E,$00
S0019:
	.byte	$47,$49,$54,$48,$55,$42,$2E,$43,$4F,$4D,$2F,$CB,$49,$4D,$CA,$4F
	.byte	$52,$47,$45,$4E,$53,$45,$4E,$2F,$CB,$55,$4E,$47,$C6,$55,$C6,$4C
	.byte	$41,$53,$48,$00
S0007:
	.byte	$C6,$41,$49,$4C,$45,$44,$20,$54,$4F,$20,$49,$4E,$53,$54,$41,$4C
	.byte	$4C,$20,$4A,$4F,$59,$53,$54,$49,$43,$4B,$20,$44,$52,$49,$56,$45
	.byte	$52,$2E,$00
S001B:
	.byte	$3C,$D2,$C5,$D4,$D5,$D2,$CE,$3E,$20,$4F,$52,$20,$C6,$49,$52,$45
	.byte	$20,$20,$20,$20,$D2,$55,$4E,$2F,$C3,$48,$41,$4E,$47,$45,$20,$C4
	.byte	$49,$52,$00
S0026:
	.byte	$CB,$D5,$CE,$C7,$20,$C6,$D5,$20,$C6,$CC,$C1,$D3,$C8,$20,$C9,$D3
	.byte	$20,$D0,$D2,$CF,$D6,$C9,$C4,$C5,$C4,$20,$D7,$C9,$D4,$C8,$20,$CE
	.byte	$CF,$00
S0009:
	.byte	$D0,$CC,$C5,$C1,$D3,$C5,$20,$C4,$CF,$20,$CE,$CF,$D4,$20,$D0,$CF
	.byte	$D7,$C5,$D2,$20,$CF,$C6,$C6,$20,$CF,$D2,$20,$D2,$C5,$D3,$C5,$D4
	.byte	$00
S0021:
	.byte	$3C,$C6,$36,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$C3,$31,$32,$38,$20,$CD,$4F,$44,$45,$00
S0012:
	.byte	$D2,$45,$43,$45,$49,$56,$45,$44,$20,$55,$4E,$53,$55,$50,$50,$4F
	.byte	$52,$54,$45,$44,$20,$43,$4F,$4D,$4D,$41,$4E,$44,$2E,$00
S0020:
	.byte	$3C,$C6,$35,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$D3,$45,$54,$54,$49,$4E,$47,$53,$00
S001D:
	.byte	$3C,$C8,$CF,$CD,$C5,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$D2,$4F,$4F,$54,$20,$C4,$49,$52,$00
S001C:
	.byte	$20,$2B,$20,$3C,$D3,$C8,$C9,$C6,$D4,$3E,$20,$4F,$52,$20,$C8,$4F
	.byte	$4C,$44,$20,$20,$CF,$50,$54,$49,$4F,$4E,$53,$00
S001E:
	.byte	$3C,$C4,$C5,$CC,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$C4,$49,$52,$20,$D5,$50,$00
S0006:
	.byte	$C6,$41,$49,$4C,$45,$44,$20,$54,$4F,$20,$41,$4C,$4C,$4F,$43,$41
	.byte	$54,$45,$20,$4D,$45,$4D,$4F,$52,$59,$2E,$00
S0024:
	.byte	$3C,$D2,$D5,$CE,$2F,$D3,$D4,$CF,$D0,$3E,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$D2,$45,$53,$45,$54,$00
S0023:
	.byte	$3C,$C6,$38,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$CB,$49,$4C,$4C,$00
S001F:
	.byte	$3C,$C6,$31,$3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$C8,$45,$4C,$50,$00
S0028:
	.byte	$D5,$D3,$C5,$20,$C9,$D4,$20,$C1,$D4,$20,$D9,$CF,$D5,$D2,$20,$CF
	.byte	$D7,$CE,$20,$D2,$C9,$D3,$CB,$21,$00
S0025:
	.byte	$D5,$53,$45,$20,$4A,$4F,$59,$53,$54,$49,$43,$4B,$20,$49,$4E,$20
	.byte	$50,$4F,$52,$54,$20,$32,$00
S0027:
	.byte	$D7,$C1,$D2,$D2,$C1,$CE,$D4,$D9,$20,$CF,$C6,$20,$C1,$CE,$D9,$20
	.byte	$CB,$C9,$CE,$C4,$2E,$00
S0018:
	.byte	$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3,$A3
	.byte	$A3,$A3,$A3,$00
S0013:
	.byte	$C3,$4F,$4D,$4D,$41,$4E,$44,$3A,$20,$25,$53,$00
S0016:
	.byte	$3E,$20,$25,$2D,$33,$34,$53,$20,$3C,$00
S002B:
	.byte	$0A,$0D,$0A,$0D,$0A,$0D,$00
S000F:
	.byte	$44,$4F,$4E,$45,$00
S0014:
	.byte	$45,$54,$59,$50,$00
S000B	:=	S000F+0
S0011:
	.byte	$4C,$4F,$41,$44,$00
S0015:
	.byte	$52,$45,$41,$44,$00
S000D	:=	S000F+0
S000A:
	.byte	$52,$53,$54,$00
S000E:
	.byte	$4D,$4E,$54,$00
S000C:
	.byte	$57,$46,$52,$00
S0010:
	.byte	$50,$52,$47,$00

.segment	"BSS"

_linebuffer:
	.res	41,$00

; ---------------------------------------------------------------
; void __near__ mainLoop (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_mainLoop: near

.segment	"CODE"

;
; for (i=0; i<EF3_USB_CMD_LEN; i++)
;
	lda     #$00
	sta     M0004
L0024:	lda     M0004
	cmp     #$0C
	bcs     L0006
;
; cmd = ef3usb_check_cmd();
;
	jsr     _ef3usb_check_cmd
	sta     M0001
	stx     M0001+1
;
; for (i=0; i<EF3_USB_CMD_LEN; i++)
;
	inc     M0004
	jmp     L0024
;
; send_fclose = false;
;
L0006:	lda     #$00
	sta     M0003
;
; if (cmd == NULL)
;
	lda     M0001
	ora     M0001+1
	bne     L0009
;
; showMessage("Communication with cartridge failed.", errorc);
;
	lda     #<(S0008)
	ldx     #>(S0008)
	jsr     pushax
	lda     _errorc
	jsr     _showMessage
;
; else if (cmd[0] == 'm' && cmd[1] == 's')    // Show message
;
	jmp     L0022
L0009:	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$4D
	jne     L000C
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	iny
	lda     (ptr1),y
	cmp     #$53
	jne     L000C
;
; uint8_t color = textc;                  // msg: Normal message
;
	lda     _textc
	sta     M0005
;
; if (cmd[2] == 'w')                      // msw: Warning message
;
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	iny
	lda     (ptr1),y
	cmp     #$57
	bne     L0010
;
; color = warnc;
;
	lda     _warnc
;
; else if (cmd[2] == 'e')                 // mse: Error message
;
	jmp     L0023
L0010:	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	lda     (ptr1),y
	cmp     #$45
	bne     L0012
;
; color = errorc;
;
	lda     _errorc
L0023:	sta     M0005
;
; text = usb_read_text();
;
L0012:	jsr     _usb_read_text
	sta     M0002
	stx     M0002+1
;
; showMessage(text, color);
;
	jsr     pushax
	lda     M0005
	jsr     _showMessage
;
; if (cmd[2] == 'w')
;
	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	cmp     #$57
	bne     L0013
;
; waitKey();
;
	jsr     _waitKey
;
; else if (cmd[2] == 'f')                 // msf: Flash programming message
;
	jmp     L0027
L0013:	lda     M0001+1
	sta     ptr1+1
	lda     M0001
	sta     ptr1
	lda     (ptr1),y
	cmp     #$46
	bne     L0027
;
; textcolor(errorc);
;
	lda     _errorc
	jsr     _textcolor
;
; cprintf("PLEASE DO NOT POWER OFF OR RESET");
;
	lda     #<(S0009)
	ldx     #>(S0009)
	jsr     pushax
	ldy     #$02
	jsr     _cprintf
;
; send_fclose = true;
;
L0027:	lda     #$01
	sta     M0003
;
; else if (strcmp(cmd, "rst") == 0)           // Reset to menu
;
	jmp     L0022
L000C:	lda     M0001
	ldx     M0001+1
	jsr     pushax
	lda     #<(S000A)
	ldx     #>(S000A)
	jsr     _strcmp
	cpx     #$00
	bne     L0017
	cmp     #$00
	bne     L0017
;
; ef3usb_send_str("done");
;
	lda     #<(S000B)
	ldx     #>(S000B)
	jsr     _ef3usb_send_str
;
; browserLoop();
;
	jsr     _browserLoop
;
; send_fclose = true;
;
	lda     #$01
	sta     M0003
;
; else if (strcmp(cmd, "wfr") == 0)           // Disable screen and wait for reset
;
	jmp     L0022
L0017:	lda     M0001
	ldx     M0001+1
	jsr     pushax
	lda     #<(S000C)
	ldx     #>(S000C)
	jsr     _strcmp
	cpx     #$00
	bne     L001A
	cmp     #$00
	bne     L001A
;
; ef3usb_send_str("done");
;
	lda     #<(S000D)
	ldx     #>(S000D)
	jsr     _ef3usb_send_str
;
; wait_for_reset();
;
	jsr     _wait_for_reset
;
; else if (strcmp(cmd, "mnt") == 0)           // Mount disk
;
	jmp     L0022
L001A:	lda     M0001
	ldx     M0001+1
	jsr     pushax
	lda     #<(S000E)
	ldx     #>(S000E)
	jsr     _strcmp
	cpx     #$00
	bne     L001D
	cmp     #$00
	bne     L001D
;
; ef3usb_send_str("done");
;
	lda     #<(S000F)
	ldx     #>(S000F)
	jsr     _ef3usb_send_str
;
; disk_mount_and_load();
;
	jsr     _disk_mount_and_load
;
; else if (strcmp(cmd, "prg") == 0)           // Load PRG
;
	jmp     L0022
L001D:	lda     M0001
	ldx     M0001+1
	jsr     pushax
	lda     #<(S0010)
	ldx     #>(S0010)
	jsr     _strcmp
	cpx     #$00
	bne     L0020
	cmp     #$00
	bne     L0020
;
; ef3usb_send_str("load");
;
	lda     #<(S0011)
	ldx     #>(S0011)
	jsr     _ef3usb_send_str
;
; usbtool_prg_load_and_run();
;
	jsr     _usbtool_prg_load_and_run
;
; else
;
	jmp     L0022
;
; showMessage("Received unsupported command.", errorc);
;
L0020:	lda     #<(S0012)
	ldx     #>(S0012)
	jsr     pushax
	lda     _errorc
	jsr     _showMessage
;
; cprintf("Command: %s", cmd);
;
	lda     #<(S0013)
	ldx     #>(S0013)
	jsr     pushax
	lda     M0001
	ldx     M0001+1
	jsr     pushax
	ldy     #$04
	jsr     _cprintf
;
; ef3usb_send_str("etyp");
;
	lda     #<(S0014)
	ldx     #>(S0014)
	jsr     _ef3usb_send_str
;
; cmd = ef3usb_get_cmd(send_fclose);
;
L0022:	lda     M0003
	jsr     _ef3usb_get_cmd
	sta     M0001
	stx     M0001+1
;
; while (true)
;
	jmp     L0006

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ browserLoop (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_browserLoop: near

.segment	"CODE"

;
; char *element = NULL;
;
	lda     #$00
	sta     M0001
	sta     M0001+1
;
; uint8_t c, j, last_selected = 0;
;
	sta     M0004
;
; uint16_t joy_cnt = 0, fire_cnt = 0;
;
	sta     M0005
	sta     M0005+1
	sta     M0006
	sta     M0006+1
;
; bool options = false, joy_down = false;
;
	sta     M0007
	sta     M0008
;
; uint8_t kff_cmd = CMD_DIR;
;
	lda     #$01
	sta     M0009
;
; memset(dir, 0, sizeof(Directory));
;
	lda     _dir
	ldx     _dir+1
	jsr     pushax
	ldx     #$03
	lda     #$80
	jsr     __bzero
;
; updateScreen();
;
	jsr     _updateScreen
;
; c = kbhit() ? cgetc() : 0;
;
L0002:	jsr     _kbhit
	tax
	beq     L0049
	jsr     _cgetc
L0049:	sta     M0002
;
; if (!c)
;
	lda     M0002
	jne     L0021
;
; j = joy_read(1);
;
	lda     #$01
	jsr     _joy_read
	sta     M0003
;
; c = JOY_UP(j) ? CH_CURS_UP :
;
	and     #$01
	beq     L004A
	ldx     #$00
	lda     #$91
;
; JOY_DOWN(j) ? CH_CURS_DOWN :
;
	jmp     L004F
L004A:	lda     M0003
	and     #$02
	beq     L004B
	ldx     #$00
	lda     #$11
;
; JOY_LEFT(j) ? CH_CURS_LEFT :
;
	jmp     L004F
L004B:	lda     M0003
	and     #$04
	beq     L004C
	ldx     #$00
	lda     #$9D
;
; JOY_RIGHT(j) ? CH_CURS_RIGHT :
;
	jmp     L004F
L004C:	lda     M0003
	and     #$08
	beq     L004D
	ldx     #$00
	lda     #$1D
;
; JOY_BTN_1(j) ? CH_ENTER : 0;
;
	jmp     L004F
L004D:	lda     M0003
	ldx     #$00
	and     #$10
	beq     L004F
	lda     #$0D
L004F:	sta     M0002
;
; if (c)
;
	lda     M0002
	jeq     L0012
;
; if (joy_cnt)
;
	lda     M0005
	ora     M0005+1
	beq     L0050
;
; c = 0;
;
	stx     M0002
;
; else if (c == CH_ENTER)
;
	jmp     L0021
L0050:	lda     M0002
	cmp     #$0D
	bne     L0052
;
; if (fire_cnt < LONG_PRESS)
;
	lda     M0006+1
	cmp     #$07
	bne     L0017
	lda     M0006
	cmp     #$D0
L0017:	bcs     L0016
;
; fire_cnt++;
;
	inc     M0006
	bne     L0018
	inc     M0006+1
;
; c = 0;
;
L0018:	stx     M0002
;
; else if (fire_cnt == LONG_PRESS)
;
	jmp     L0021
L0016:	lda     M0006+1
	cmp     #$07
	bne     L0051
	lda     M0006
	cmp     #$D0
	bne     L0051
;
; fire_cnt++;
;
	inc     M0006
	bne     L001C
	inc     M0006+1
;
; joy_cnt = 30;
;
L001C:	lda     #$1E
	sta     M0005
	stx     M0005+1
;
; c = CH_SHIFT_ENTER;
;
	lda     #$8D
	sta     M0002
;
; else
;
	jmp     L0021
;
; c = 0;
;
L0051:	stx     M0002
;
; else
;
	jmp     L0021
;
; fire_cnt = 0;
;
L0052:	txa
	sta     M0006
	sta     M0006+1
;
; joy_cnt = joy_down ? 120 : 1200;
;
	lda     M0008
	beq     L001F
	lda     #$78
	jmp     L0020
L001F:	ldx     #$04
	lda     #$B0
L0020:	sta     M0005
	stx     M0005+1
;
; joy_down = true;
;
	lda     #$01
	sta     M0008
;
; else
;
	jmp     L0021
;
; if (fire_cnt && fire_cnt < LONG_PRESS)
;
L0012:	lda     M0006
	ora     M0006+1
	beq     L0057
	lda     M0006+1
	cmp     #$07
	bne     L0024
	lda     M0006
	cmp     #$D0
L0024:	bcs     L0061
;
; c = CH_ENTER;
;
	lda     #$0D
	sta     M0002
;
; fire_cnt = 0;
;
L0061:	txa
L0057:	sta     M0006
	sta     M0006+1
;
; joy_down = false;
;
	sta     M0008
;
; joy_cnt = 30;
;
	lda     #$1E
	sta     M0005
	stx     M0005+1
;
; if (joy_cnt)
;
L0021:	lda     M0005
	ora     M0005+1
	beq     L0058
;
; joy_cnt--;
;
	lda     M0005
	sec
	sbc     #$01
	sta     M0005
	bcs     L0058
	dec     M0005+1
;
; switch (c)
;
L0058:	lda     M0002
;
; }
;
	cmp     #$03
	jeq     L005F
	cmp     #$0D
	beq     L002B
	cmp     #$11
	beq     L0030
	cmp     #$13
	beq     L005A
	cmp     #$14
	beq     L0059
	cmp     #$1D
	jeq     L0039
	cmp     #$85
	jeq     L003F
	cmp     #$87
	jeq     L005B
	cmp     #$88
	jeq     L005D
	cmp     #$8B
	jeq     L005C
	cmp     #$8C
	jeq     L005E
	cmp     #$8D
	beq     L002B
	cmp     #$91
	jeq     L0035
	cmp     #$9D
	jeq     L003D
	jmp     L0060
;
; if (dir->no_of_elements)
;
L002B:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	jeq     L0060
;
; options = c == CH_SHIFT_ENTER;
;
	lda     M0002
	cmp     #$8D
	jsr     booleq
	sta     M0007
;
; kff_cmd = CMD_SELECT;
;
	lda     #$06
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_DIR_UP;
;
L0059:	lda     #$03
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_DIR_ROOT;
;
L005A:	lda     #$02
;
; break;
;
	jmp     L0047
;
; if (dir->no_of_elements)
;
L0030:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	jeq     L0060
;
; last_selected = dir->selected;
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     M0004
;
; if ((dir->selected+1) < dir->no_of_elements)
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldx     #$00
	lda     (ptr1),y
	jsr     incax1
	jsr     pushax
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	jsr     tosicmp0
	bpl     L0032
;
; dir->selected++;
;
	lda     _dir
	ldx     _dir+1
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$25
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (sreg),y
;
; updateDir(last_selected);
;
	lda     M0004
	jsr     _updateDir
;
; else if (dir->no_of_elements == MAX_ELEMENTS_PAGE)
;
	jmp     L0060
L0032:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	cmp     #$16
	jne     L0060
;
; dir->selected = 0;
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     #$00
	ldy     #$25
	sta     (ptr1),y
;
; kff_cmd = CMD_DIR_NEXT_PAGE;
;
	lda     #$05
;
; break;
;
	jmp     L0047
;
; if (dir->no_of_elements)
;
L0035:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	jeq     L0060
;
; last_selected = dir->selected;
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     M0004
;
; if (dir->selected > dir->text_elements)
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	dey
	lda     (ptr1),y
	cmp     sreg
	bcs     L0037
;
; dir->selected--;
;
	lda     _dir
	ldx     _dir+1
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	iny
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (sreg),y
;
; updateDir(last_selected);
;
	lda     M0004
	jsr     _updateDir
;
; else
;
	jmp     L0060
;
; dir->selected = MAX_ELEMENTS_PAGE-1;
;
L0037:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     #$15
	iny
	sta     (ptr1),y
;
; kff_cmd = CMD_DIR_PREV_PAGE;
;
	lda     #$04
;
; break;
;
	jmp     L0047
;
; if (dir->no_of_elements)
;
L0039:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	jeq     L0060
;
; if (dir->no_of_elements < MAX_ELEMENTS_PAGE)
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	cmp     #$16
	bcs     L003B
;
; last_selected = dir->selected;
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     M0004
;
; dir->selected = dir->no_of_elements-1;
;
	lda     _dir+1
	sta     sreg+1
	lda     _dir
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	sec
	sbc     #$01
	ldy     #$25
	sta     (sreg),y
;
; updateDir(last_selected);
;
	lda     M0004
	jsr     _updateDir
;
; else
;
	jmp     L0060
;
; last_selected = dir->no_of_elements-1;
;
L003B:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     M0004
;
; kff_cmd = CMD_DIR_NEXT_PAGE;
;
	lda     #$05
;
; break;
;
	jmp     L0047
;
; if (dir->no_of_elements)
;
L003D:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	beq     L0060
;
; last_selected = 0;
;
	lda     #$00
	sta     M0004
;
; kff_cmd = CMD_DIR_PREV_PAGE;
;
	lda     #$04
;
; break;
;
	jmp     L0047
;
; help();
;
L003F:	jsr     _help
;
; break;
;
	jmp     L0060
;
; kff_cmd = CMD_SETTINGS;
;
L005B:	lda     #$07
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_KILL_C128;
;
L005C:	lda     #$0A
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_BASIC;
;
L005D:	lda     #$08
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_KILL;
;
L005E:	lda     #$09
;
; break;
;
	jmp     L0047
;
; kff_cmd = CMD_RESET;
;
L005F:	lda     #$0B
L0047:	sta     M0009
;
; if (kff_cmd != CMD_NONE)
;
L0060:	lda     M0009
	jeq     L0002
;
; if(handleCommand(kff_cmd, options, last_selected))
;
	jsr     pusha
	lda     M0007
	jsr     pusha
	lda     M0004
	jsr     _handleCommand
	tax
;
; break;
;
	bne     L0003
;
; kff_cmd = CMD_NONE;
;
	sta     M0009
;
; while (true)
;
	jmp     L0002
;
; }
;
L0003:	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	1,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	2,$00
M0006:
	.res	2,$00
M0007:
	.res	1,$00
M0008:
	.res	1,$00
M0009:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ updateScreen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateScreen: near

.segment	"CODE"

;
; clrscr();
;
	jsr     _clrscr
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; textcolor(backc);
;
	lda     _backc
	jsr     _textcolor
;
; drawFrame();
;
	jsr     _drawFrame
;
; gotoxy(0, BOTTOM);
;
	lda     #$00
	jsr     pusha
	lda     #$18
	jsr     _gotoxy
;
; revers(1);
;
	lda     #$01
	jsr     _revers
;
; cputs(menuBar);
;
	lda     #<(_menuBar)
	ldx     #>(_menuBar)
	jsr     _cputs
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; showDir();
;
	jmp     _showDir

.endproc

; ---------------------------------------------------------------
; void __near__ help (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_help: near

.segment	"CODE"

;
; clrscr();
;
	jsr     _clrscr
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; textcolor(textc);
;
	lda     _textc
	jsr     _textcolor
;
; gotoxy(0, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _gotoxy
;
; cputs(programBar);
;
	lda     #<(_programBar)
	ldx     #>(_programBar)
	jsr     _cputs
;
; textcolor(backc);
;
	lda     _backc
	jsr     _textcolor
;
; gotoxy(10, 1);
;
	lda     #$0A
	jsr     pusha
	lda     #$01
	jsr     _gotoxy
;
; cputs("\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3\xa3");
;
	lda     #<(S0018)
	ldx     #>(S0018)
	jsr     _cputs
;
; gotoxy(2, 2);
;
	lda     #$02
	jsr     pusha
	jsr     _gotoxy
;
; cputs("github.com/KimJorgensen/KungFuFlash");
;
	lda     #<(S0019)
	ldx     #>(S0019)
	jsr     _cputs
;
; textcolor(textc);
;
	lda     _textc
	jsr     _textcolor
;
; gotoxy(0, 5);
;
	lda     #$00
	jsr     pusha
	lda     #$05
	jsr     _gotoxy
;
; cputs("<CRSR> or Joy       Change selection");
;
	lda     #<(S001A)
	ldx     #>(S001A)
	jsr     _cputs
;
; gotoxy(0, 6);
;
	lda     #$00
	jsr     pusha
	lda     #$06
	jsr     _gotoxy
;
; cputs("<RETURN> or Fire    Run/Change Dir");
;
	lda     #<(S001B)
	ldx     #>(S001B)
	jsr     _cputs
;
; gotoxy(0, 7);
;
	lda     #$00
	jsr     pusha
	lda     #$07
	jsr     _gotoxy
;
; cputs(" + <SHIFT> or Hold  Options");
;
	lda     #<(S001C)
	ldx     #>(S001C)
	jsr     _cputs
;
; gotoxy(0, 8);
;
	lda     #$00
	jsr     pusha
	lda     #$08
	jsr     _gotoxy
;
; cputs("<HOME>              Root Dir");
;
	lda     #<(S001D)
	ldx     #>(S001D)
	jsr     _cputs
;
; gotoxy(0, 9);
;
	lda     #$00
	jsr     pusha
	lda     #$09
	jsr     _gotoxy
;
; cputs("<DEL>               Dir Up");
;
	lda     #<(S001E)
	ldx     #>(S001E)
	jsr     _cputs
;
; gotoxy(0, 10);
;
	lda     #$00
	jsr     pusha
	lda     #$0A
	jsr     _gotoxy
;
; cputs("<F1>                Help");
;
	lda     #<(S001F)
	ldx     #>(S001F)
	jsr     _cputs
;
; gotoxy(0, 11);
;
	lda     #$00
	jsr     pusha
	lda     #$0B
	jsr     _gotoxy
;
; cputs("<F5>                Settings");
;
	lda     #<(S0020)
	ldx     #>(S0020)
	jsr     _cputs
;
; gotoxy(0, 12);
;
	lda     #$00
	jsr     pusha
	lda     #$0C
	jsr     _gotoxy
;
; cputs("<F6>                C128 Mode");
;
	lda     #<(S0021)
	ldx     #>(S0021)
	jsr     _cputs
;
; gotoxy(0, 13);
;
	lda     #$00
	jsr     pusha
	lda     #$0D
	jsr     _gotoxy
;
; cputs("<F7>                BASIC (Cart Active)");
;
	lda     #<(S0022)
	ldx     #>(S0022)
	jsr     _cputs
;
; gotoxy(0, 14);
;
	lda     #$00
	jsr     pusha
	lda     #$0E
	jsr     _gotoxy
;
; cputs("<F8>                Kill");
;
	lda     #<(S0023)
	ldx     #>(S0023)
	jsr     _cputs
;
; gotoxy(0, 15);
;
	lda     #$00
	jsr     pusha
	lda     #$0F
	jsr     _gotoxy
;
; cputs("<RUN/STOP>          Reset");
;
	lda     #<(S0024)
	ldx     #>(S0024)
	jsr     _cputs
;
; gotoxy(0, 17);
;
	lda     #$00
	jsr     pusha
	lda     #$11
	jsr     _gotoxy
;
; cputs("Use joystick in port 2");
;
	lda     #<(S0025)
	ldx     #>(S0025)
	jsr     _cputs
;
; textcolor(COLOR_RED);
;
	lda     #$02
	jsr     _textcolor
;
; gotoxy(0, 19);
;
	lda     #$00
	jsr     pusha
	lda     #$13
	jsr     _gotoxy
;
; cputs("KUNG FU FLASH IS PROVIDED WITH NO");
;
	lda     #<(S0026)
	ldx     #>(S0026)
	jsr     _cputs
;
; gotoxy(0, 20);
;
	lda     #$00
	jsr     pusha
	lda     #$14
	jsr     _gotoxy
;
; cputs("WARRANTY OF ANY KIND.");
;
	lda     #<(S0027)
	ldx     #>(S0027)
	jsr     _cputs
;
; gotoxy(0, 21);
;
	lda     #$00
	jsr     pusha
	lda     #$15
	jsr     _gotoxy
;
; textcolor(COLOR_LIGHTRED);
;
	lda     #$0A
	jsr     _textcolor
;
; cputs("USE IT AT YOUR OWN RISK!");
;
	lda     #<(S0028)
	ldx     #>(S0028)
	jsr     _cputs
;
; gotoxy(0, 24);
;
	lda     #$00
	jsr     pusha
	lda     #$18
	jsr     _gotoxy
;
; waitKey();
;
	jsr     _waitKey
;
; updateScreen();
;
	jmp     _updateScreen

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ handleCommand (unsigned char cmd, unsigned char options, unsigned char last_selected)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_handleCommand: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; bool quit_browser = false;
;
	lda     #$00
	sta     M0001
;
; if (cmd != CMD_SELECT)
;
	ldy     #$02
	lda     (sp),y
	cmp     #$06
	beq     L0002
;
; reply = kff_send_command(cmd);
;
	jsr     _kff_send_command
;
; else
;
	jmp     L0013
;
; data = dir->selected;
;
L0002:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     M0002
;
; if (isC128)
;
	lda     _isC128
	beq     L0004
;
; data |= SELECT_FLAG_C128;
;
	lda     M0002
	ora     #$80
	sta     M0002
;
; if (options)
;
L0004:	ldy     #$01
	lda     (sp),y
	beq     L0005
;
; data |= SELECT_FLAG_OPTIONS;
;
	lda     M0002
	ora     #$40
	sta     M0002
;
; reply = kff_send_ext_command(cmd, data);
;
L0005:	iny
	lda     (sp),y
	jsr     pusha
	lda     M0002
	jsr     _kff_send_ext_command
L0013:	sta     M0003
;
; switch (reply)
;
	ldx     #$00
	lda     M0003
;
; }
;
	jeq     L0017
	cmp     #$01
	beq     L0009
	cmp     #$02
	beq     L000A
	cmp     #$03
	jeq     L0016
	jmp     L0017
;
; readDir(dir);
;
L0009:	lda     _dir
	ldx     _dir+1
	jsr     _readDir
;
; showDir();
;
	jsr     _showDir
;
; break;
;
	jmp     L0007
;
; if (!readDirPage(dir))
;
L000A:	lda     _dir
	ldx     _dir+1
	jsr     _readDirPage
	tax
	bne     L000B
;
; dir->selected = last_selected;
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (sp,x)
	ldy     #$25
	sta     (ptr1),y
;
; if (dir->selected >= dir->no_of_elements)
;
L000B:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	cmp     sreg
	beq     L0012
	bcs     L000C
;
; dir->selected = dir->no_of_elements ? dir->no_of_elements-1 : 0;
;
L0012:	lda     _dir+1
	sta     sreg+1
	lda     _dir
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	beq     L0015
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	sec
	sbc     #$01
L0015:	ldy     #$25
	sta     (sreg),y
;
; if (dir->selected < dir->text_elements)
;
L000C:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	dey
	lda     (ptr1),y
	cmp     sreg
	bcc     L000F
	beq     L000F
;
; dir->selected = dir->text_elements;
;
	lda     _dir+1
	sta     sreg+1
	lda     _dir
	sta     sreg
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	lda     (ptr1),y
	iny
	sta     (sreg),y
;
; printDirPage();
;
L000F:	jsr     _printDirPage
;
; break;
;
	jmp     L0007
;
; quit_browser = true;
;
L0016:	lda     #$01
	sta     M0001
;
; break;
;
	jmp     L0017
;
; return quit_browser;
;
L0007:	ldx     #$00
L0017:	lda     M0001
;
; }
;
	jmp     incsp3

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00
M0003:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ showDir (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_showDir: near

.segment	"CODE"

;
; if (dir->name[0] != NULL)
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	beq     L0002
;
; sprintf(linebuffer, "> %-34s <", dir->name);
;
	lda     #<(_linebuffer)
	ldx     #>(_linebuffer)
	jsr     pushax
	lda     #<(S0016)
	ldx     #>(S0016)
	jsr     pushax
	lda     _dir
	ldx     _dir+1
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; title = linebuffer;
;
	lda     #>(_linebuffer)
	sta     M0001+1
	lda     #<(_linebuffer)
;
; else
;
	jmp     L0004
;
; title = "                                      ";
;
L0002:	lda     #>(S0017)
	sta     M0001+1
	lda     #<(S0017)
L0004:	sta     M0001
;
; gotoxy(1, 0);
;
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _gotoxy
;
; textcolor(backc);
;
	lda     _backc
	jsr     _textcolor
;
; revers(1);
;
	lda     #$01
	jsr     _revers
;
; cputs(title);
;
	lda     M0001
	ldx     M0001+1
	jsr     _cputs
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; printDirPage();
;
	jmp     _printDirPage

.segment	"BSS"

M0001:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ updateDir (unsigned char last_selected)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateDir: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; printElement(last_selected);
;
	ldy     #$00
	lda     (sp),y
	jsr     _printElement
;
; printElement(dir->selected);
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	jsr     _printElement
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ printDirPage (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printDirPage: near

.segment	"CODE"

;
; uint8_t element_no = 0;
;
	lda     #$00
	sta     M0001
;
; for (;element_no < dir->no_of_elements; element_no++)
;
L0002:	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$23
	lda     (ptr1),y
	cmp     M0001
	beq     L000B
	bcc     L000B
;
; printElement(element_no);
;
	lda     M0001
	jsr     _printElement
;
; for (;element_no < dir->no_of_elements; element_no++)
;
	inc     M0001
	jmp     L0002
;
; for (;element_no < DIRH; element_no++)
;
L000B:	lda     M0001
	cmp     #$16
	bcs     L0007
;
; gotoxy(1, 1+element_no);
;
	lda     #$01
	jsr     pusha
	lda     M0001
	clc
	adc     #$01
	jsr     _gotoxy
;
; cputs("                                      ");
;
	lda     #<(S0029)
	ldx     #>(S0029)
	jsr     _cputs
;
; for (;element_no < DIRH; element_no++)
;
	inc     M0001
	jmp     L000B
;
; }
;
L0007:	rts

.segment	"BSS"

M0001:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ printElement (unsigned char element_no)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printElement: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; element = dir->elements[element_no];
;
	lda     _dir
	ldx     _dir+1
	ldy     #$26
	jsr     incaxy
	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     pusha0
	lda     #$27
	jsr     tosmula0
	jsr     tosaddax
	sta     M0001
	stx     M0001+1
;
; if (element[0] == TEXT_ELEMENT)
;
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$E0
	bne     L0002
;
; textcolor(warnc);
;
	lda     _warnc
;
; else
;
	jmp     L0006
;
; textcolor(textc);
;
L0002:	lda     _textc
L0006:	jsr     _textcolor
;
; if (element_no == dir->selected)
;
	lda     _dir+1
	sta     ptr1+1
	lda     _dir
	sta     ptr1
	ldy     #$25
	lda     (ptr1),y
	ldy     #$00
	cmp     (sp),y
	bne     L0004
;
; revers(1);
;
	lda     #$01
;
; else
;
	jmp     L0007
;
; revers(0);
;
L0004:	tya
L0007:	jsr     _revers
;
; gotoxy(1, 1+element_no);
;
	lda     #$01
	jsr     pusha
	tay
	lda     (sp),y
	clc
	adc     #$01
	jsr     _gotoxy
;
; cputs(element);
;
	lda     M0001
	ldx     M0001+1
	jsr     _cputs
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; }
;
	jmp     incsp1

.segment	"BSS"

M0001:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; const char *__near__ usb_read_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_usb_read_text: near

.segment	"CODE"

;
; ef3usb_send_str("read");
;
	lda     #<(S0015)
	ldx     #>(S0015)
	jsr     _ef3usb_send_str
;
; ef3usb_receive_data(&size, 2);
;
	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     pushax
	ldx     #$00
	lda     #$02
	jsr     _ef3usb_receive_data
;
; ef3usb_receive_data(bigBuffer, size);
;
	lda     _bigBuffer
	ldx     _bigBuffer+1
	jsr     pushax
	lda     M0001
	ldx     M0001+1
	jsr     _ef3usb_receive_data
;
; bigBuffer[size] = 0;
;
	lda     _bigBuffer
	clc
	adc     M0001
	sta     ptr1
	lda     _bigBuffer+1
	adc     M0001+1
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; return bigBuffer;
;
	lda     _bigBuffer
	ldx     _bigBuffer+1
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ showMessage (const char *text, unsigned char color)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_showMessage: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; clrscr();
;
	jsr     _clrscr
;
; revers(1);
;
	lda     #$01
	jsr     _revers
;
; textcolor(backc);
;
	lda     _backc
	jsr     _textcolor
;
; gotoxy(0, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _gotoxy
;
; cputs("                                        ");
;
	lda     #<(S002A)
	ldx     #>(S002A)
	jsr     _cputs
;
; gotoxy(0, BOTTOM);
;
	lda     #$00
	jsr     pusha
	lda     #$18
	jsr     _gotoxy
;
; cputs(programBar);
;
	lda     #<(_programBar)
	ldx     #>(_programBar)
	jsr     _cputs
;
; revers(0);
;
	lda     #$00
	jsr     _revers
;
; textcolor(color);
;
	ldy     #$00
	lda     (sp),y
	jsr     _textcolor
;
; gotoxy(0, 3);
;
	lda     #$00
	jsr     pusha
	lda     #$03
	jsr     _gotoxy
;
; cputs(text);
;
	ldy     #$02
	jsr     ldaxysp
	jsr     _cputs
;
; cputs("\r\n\r\n\r\n");
;
	lda     #<(S002B)
	ldx     #>(S002B)
	jsr     _cputs
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; initScreen(COLOR_BLACK, COLOR_BLACK, textc);
;
	lda     #$00
	jsr     pusha
	jsr     pusha
	lda     _textc
	jsr     _initScreen
;
; dir = (Directory *)malloc(sizeof(Directory));
;
	ldx     #$03
	lda     #$80
	jsr     _malloc
	sta     _dir
	stx     _dir+1
;
; bigBuffer = (uint8_t *)dir;
;
	sta     _bigBuffer
	stx     _bigBuffer+1
;
; if (dir == NULL)
;
	lda     _dir
	ora     _dir+1
	bne     L0005
;
; showMessage("Failed to allocate memory.", errorc);
;
	lda     #<(S0006)
	ldx     #>(S0006)
	jsr     pushax
	lda     _errorc
	jsr     _showMessage
;
; while (true);
;
L000B:	jmp     L000B
;
; if (joy_install(&joy_static_stddrv) != JOY_ERR_OK)
;
L0005:	lda     #<(_joy_static_stddrv)
	ldx     #>(_joy_static_stddrv)
	jsr     _joy_install
	cmp     #$00
	beq     L0009
;
; showMessage("Failed to install joystick driver.", errorc);
;
	lda     #<(S0007)
	ldx     #>(S0007)
	jsr     pushax
	lda     _errorc
	jsr     _showMessage
;
; while (true);
;
L000C:	jmp     L000C
;
; isC128 = is_c128() != 0;
;
L0009:	jsr     _is_c128
	cmp     #$00
	jsr     boolne
	sta     _isC128
;
; mainLoop();
;
	jsr     _mainLoop
;
; free(dir);
;
	lda     _dir
	ldx     _dir+1
	jsr     _free
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

