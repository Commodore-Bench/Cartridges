;
; File generated by cc65 v 2.18 - Git 947dd9a
;
	.fopt		compiler,"cc65 v 2.18 - Git 947dd9a"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_memcpy
	.export		_readDir
	.export		_readDirPage
	.import		_ef3usb_receive_data

; ---------------------------------------------------------------
; void __near__ readDir (struct $anon-struct-0016 *dir)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readDir: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; dir->name[0] = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; dir->no_of_elements = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$23
	sta     (ptr1),y
;
; dir->text_elements = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$24
	sta     (ptr1),y
;
; dir->selected = 0;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     #$00
	ldy     #$25
	sta     (ptr1),y
;
; ef3usb_receive_data(dir->name, DIR_NAME_LENGTH);
;
	jsr     pushw0sp
	ldx     #$00
	lda     #$22
	jsr     _ef3usb_receive_data
;
; readDirPage(dir);
;
	jsr     ldax0sp
	jsr     _readDirPage
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readDirPage (struct $anon-struct-0016 *dir)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readDirPage: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; uint8_t element_no = 0;
;
	lda     #$00
	sta     M0001
;
; char *element = first_element;
;
	lda     #>(M0002)
	sta     M0003+1
	lda     #<(M0002)
	sta     M0003
;
; ef3usb_receive_data(element, ELEMENT_LENGTH);
;
L0002:	lda     M0003
	ldx     M0003+1
	jsr     pushax
	ldx     #$00
	lda     #$26
	jsr     _ef3usb_receive_data
;
; if (element[0] == 0)
;
	lda     M0003+1
	sta     ptr1+1
	lda     M0003
	sta     ptr1
	ldx     #$00
	lda     (ptr1,x)
;
; break;
;
	beq     L0003
;
; if (element[0] == TEXT_ELEMENT)
;
	lda     M0003+1
	sta     ptr1+1
	lda     M0003
	sta     ptr1
	lda     (ptr1,x)
	cmp     #$E0
	bne     L0006
;
; dir->text_elements++;
;
	jsr     ldax0sp
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$24
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (sreg),y
;
; else if (element[0] == SELECTED_ELEMENT)
;
	jmp     L0008
L0006:	lda     M0003+1
	sta     ptr1+1
	lda     M0003
	sta     ptr1
	lda     (ptr1,x)
	cmp     #$A0
	bne     L0008
;
; dir->selected = element_no;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     M0001
	ldy     #$25
	sta     (ptr1),y
;
; element = dir->elements[++element_no];
;
L0008:	jsr     ldax0sp
	ldy     #$26
	jsr     incaxy
	jsr     pushax
	inc     M0001
	lda     M0001
	jsr     pusha0
	lda     #$27
	jsr     tosmula0
	jsr     tosaddax
	sta     M0003
	stx     M0003+1
;
; while (element_no < MAX_ELEMENTS_PAGE);
;
	ldx     #$00
	lda     M0001
	cmp     #$16
	jcc     L0002
;
; if (element_no)
;
L0003:	lda     M0001
	beq     L000A
;
; memcpy(&dir->elements[0], first_element, sizeof(first_element));
;
	jsr     ldax0sp
	ldy     #$26
	jsr     incaxy
	jsr     pushax
	lda     #<(M0002)
	ldx     #>(M0002)
	jsr     pushax
	ldx     #$00
	lda     #$27
	jsr     _memcpy
;
; dir->no_of_elements = element_no;
;
	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	lda     M0001
	ldy     #$23
	sta     (ptr1),y
;
; return element_no;
;
	ldx     #$00
L000A:	lda     M0001
;
; }
;
	jmp     incsp2

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	39,$00
M0003:
	.res	2,$00

.endproc

